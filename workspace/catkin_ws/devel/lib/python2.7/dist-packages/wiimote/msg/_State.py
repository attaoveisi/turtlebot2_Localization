# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from wiimote/State.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import genpy
import geometry_msgs.msg
import std_msgs.msg
import wiimote.msg

class State(genpy.Message):
  _md5sum = "a69651e8129655c6ed3c5039e468362c"
  _type = "wiimote/State"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """#
#          Wiimote State message containing one complete Wiimote state

# Note: For ease of manipulation this message often uses
#       int8[] when a bit vector would work. One might
#       wish to use uint8[], but then Python takes
#       the respective structure as a string and disallows
#       item assignment.

int8    INVALID       = -1
float32 INVALID_FLOAT = -1.0

int8 MSG_BTN_1     = 0
int8 MSG_BTN_2     = 1
int8 MSG_BTN_A     = 2
int8 MSG_BTN_B     = 3
int8 MSG_BTN_PLUS  = 4
int8 MSG_BTN_MINUS = 5
int8 MSG_BTN_LEFT  = 6
int8 MSG_BTN_RIGHT = 7
int8 MSG_BTN_UP    = 8
int8 MSG_BTN_DOWN  = 9
int8 MSG_BTN_HOME  = 10
int8 MSG_BTN_Z     = 0
int8 MSG_BTN_C     = 1
int8 MSG_CLASSIC_BTN_X       = 0
int8 MSG_CLASSIC_BTN_Y       = 1
int8 MSG_CLASSIC_BTN_A       = 2
int8 MSG_CLASSIC_BTN_B       = 3
int8 MSG_CLASSIC_BTN_PLUS    = 4
int8 MSG_CLASSIC_BTN_MINUS   = 5
int8 MSG_CLASSIC_BTN_LEFT    = 6
int8 MSG_CLASSIC_BTN_RIGHT   = 7
int8 MSG_CLASSIC_BTN_UP      = 8
int8 MSG_CLASSIC_BTN_DOWN    = 9
int8 MSG_CLASSIC_BTN_HOME    = 10
int8 MSG_CLASSIC_BTN_L       = 11
int8 MSG_CLASSIC_BTN_R       = 12
int8 MSG_CLASSIC_BTN_ZL      = 13
int8 MSG_CLASSIC_BTN_ZR      = 14

#-----------------------------
# Header
#----------------------

Header header

#----------------------
# Gyro reading
#-----------------------------
# In radians/sec. If reading is invalid,
# for instance b/c no gyro is attached to the Wii, then
# set first element of covariance to -1 (same as imu_data.msg):
# Covariance matrix (roll, pitch, yaw) in radians^2/sec^2.

geometry_msgs/Vector3 angular_velocity_zeroed
geometry_msgs/Vector3 angular_velocity_raw
float64[9] angular_velocity_covariance

#----------------------
# Accelerometer reading
#-----------------------------
# Acceleration in m/sec^2. Covariance matrix
# (x,y,z) in m^2/sec^4.  (all same as imu_data.msg)

geometry_msgs/Vector3 linear_acceleration_zeroed
geometry_msgs/Vector3 linear_acceleration_raw
float64[9] linear_acceleration_covariance

#------------------------------
# Nunchuk Accelerometer reading
#------------------------------
geometry_msgs/Vector3 nunchuk_acceleration_zeroed
geometry_msgs/Vector3 nunchuk_acceleration_raw

#-----------------
# Nunchuk Joystick
#-----------------
float32[2] nunchuk_joystick_zeroed
float32[2] nunchuk_joystick_raw

#----------------------
# Wiimote buttons
#-----------------------------
# Mappings from Wiimote button name
# to array position are defined above.
#
bool[11] buttons
bool[2] nunchuk_buttons

#----------------------
# Wiimote LED states:
#-----------------------------

bool[4] LEDs

#----------------------
# Wiimote Rumble
#-----------------------------
# State (True or False)

bool rumble

#----------------------
# IR Light sensor (Camera)
#-----------------------------
# The Wiimote handles up to four light sources, 
# and the wiimote_node.py software is written to 
# that limit as well. For future expansion
# we make the following array extensible, rather
# than locking its length down to four:

wiimote/IrSourceInfo[] ir_tracking

#----------------------
# Wiimote battery
#-----------------------------
# A battery reading consists of two numbers: 
# the battery percentage, and the raw reading.
# Maximum battery is 208 units (unknown how this
# relates to electrical properties): 

float32 raw_battery
float32 percent_battery

#----------------------
# Time of most recent zeroing:
#-----------------------------

time zeroing_time

#----------------------
# Error vector
#-----------------------------
# For error condition definitions see wiimoteConstants.py
# Value of zero means all is well. (Currently NOT used).

uint64 errors

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: wiimote/IrSourceInfo
# Sensor data pertaining to the Wiimote infrared camera.
# This message contains data for one of the four infrared 
# light sources that the camera detects.
#
# Each light is specified with a 2D position and 
# a 'source magnitude' (ir_size). If the x dimension
# is set to INVALID_FLOAT, then no light was detected for 
# the respective light. The Wiimote handles up to
# four light sources, and the wiimote_node.py software
# is written to that limit as well.
#
# I am unsure what the 'ir_size' values represent. 
# They are described as 'source magnitude' in some places. I
# *assume* this is signal amplitude, but it's unclear. 
# Note that current lowest level cwiid driver does not 
# seem to pass the ir_size value to the cwiid Wiimote.c. 
# For now this size will therefore be set INVALID

float64 x 
float64 y 
int64 ir_size
"""
  # Pseudo-constants
  INVALID = -1
  INVALID_FLOAT = -1.0
  MSG_BTN_1 = 0
  MSG_BTN_2 = 1
  MSG_BTN_A = 2
  MSG_BTN_B = 3
  MSG_BTN_PLUS = 4
  MSG_BTN_MINUS = 5
  MSG_BTN_LEFT = 6
  MSG_BTN_RIGHT = 7
  MSG_BTN_UP = 8
  MSG_BTN_DOWN = 9
  MSG_BTN_HOME = 10
  MSG_BTN_Z = 0
  MSG_BTN_C = 1
  MSG_CLASSIC_BTN_X = 0
  MSG_CLASSIC_BTN_Y = 1
  MSG_CLASSIC_BTN_A = 2
  MSG_CLASSIC_BTN_B = 3
  MSG_CLASSIC_BTN_PLUS = 4
  MSG_CLASSIC_BTN_MINUS = 5
  MSG_CLASSIC_BTN_LEFT = 6
  MSG_CLASSIC_BTN_RIGHT = 7
  MSG_CLASSIC_BTN_UP = 8
  MSG_CLASSIC_BTN_DOWN = 9
  MSG_CLASSIC_BTN_HOME = 10
  MSG_CLASSIC_BTN_L = 11
  MSG_CLASSIC_BTN_R = 12
  MSG_CLASSIC_BTN_ZL = 13
  MSG_CLASSIC_BTN_ZR = 14

  __slots__ = ['header','angular_velocity_zeroed','angular_velocity_raw','angular_velocity_covariance','linear_acceleration_zeroed','linear_acceleration_raw','linear_acceleration_covariance','nunchuk_acceleration_zeroed','nunchuk_acceleration_raw','nunchuk_joystick_zeroed','nunchuk_joystick_raw','buttons','nunchuk_buttons','LEDs','rumble','ir_tracking','raw_battery','percent_battery','zeroing_time','errors']
  _slot_types = ['std_msgs/Header','geometry_msgs/Vector3','geometry_msgs/Vector3','float64[9]','geometry_msgs/Vector3','geometry_msgs/Vector3','float64[9]','geometry_msgs/Vector3','geometry_msgs/Vector3','float32[2]','float32[2]','bool[11]','bool[2]','bool[4]','bool','wiimote/IrSourceInfo[]','float32','float32','time','uint64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,angular_velocity_zeroed,angular_velocity_raw,angular_velocity_covariance,linear_acceleration_zeroed,linear_acceleration_raw,linear_acceleration_covariance,nunchuk_acceleration_zeroed,nunchuk_acceleration_raw,nunchuk_joystick_zeroed,nunchuk_joystick_raw,buttons,nunchuk_buttons,LEDs,rumble,ir_tracking,raw_battery,percent_battery,zeroing_time,errors

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(State, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.angular_velocity_zeroed is None:
        self.angular_velocity_zeroed = geometry_msgs.msg.Vector3()
      if self.angular_velocity_raw is None:
        self.angular_velocity_raw = geometry_msgs.msg.Vector3()
      if self.angular_velocity_covariance is None:
        self.angular_velocity_covariance = [0.] * 9
      if self.linear_acceleration_zeroed is None:
        self.linear_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_raw is None:
        self.linear_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_covariance is None:
        self.linear_acceleration_covariance = [0.] * 9
      if self.nunchuk_acceleration_zeroed is None:
        self.nunchuk_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.nunchuk_acceleration_raw is None:
        self.nunchuk_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.nunchuk_joystick_zeroed is None:
        self.nunchuk_joystick_zeroed = [0.] * 2
      if self.nunchuk_joystick_raw is None:
        self.nunchuk_joystick_raw = [0.] * 2
      if self.buttons is None:
        self.buttons = [False] * 11
      if self.nunchuk_buttons is None:
        self.nunchuk_buttons = [False] * 2
      if self.LEDs is None:
        self.LEDs = [False] * 4
      if self.rumble is None:
        self.rumble = False
      if self.ir_tracking is None:
        self.ir_tracking = []
      if self.raw_battery is None:
        self.raw_battery = 0.
      if self.percent_battery is None:
        self.percent_battery = 0.
      if self.zeroing_time is None:
        self.zeroing_time = genpy.Time()
      if self.errors is None:
        self.errors = 0
    else:
      self.header = std_msgs.msg.Header()
      self.angular_velocity_zeroed = geometry_msgs.msg.Vector3()
      self.angular_velocity_raw = geometry_msgs.msg.Vector3()
      self.angular_velocity_covariance = [0.] * 9
      self.linear_acceleration_zeroed = geometry_msgs.msg.Vector3()
      self.linear_acceleration_raw = geometry_msgs.msg.Vector3()
      self.linear_acceleration_covariance = [0.] * 9
      self.nunchuk_acceleration_zeroed = geometry_msgs.msg.Vector3()
      self.nunchuk_acceleration_raw = geometry_msgs.msg.Vector3()
      self.nunchuk_joystick_zeroed = [0.] * 2
      self.nunchuk_joystick_raw = [0.] * 2
      self.buttons = [False] * 11
      self.nunchuk_buttons = [False] * 2
      self.LEDs = [False] * 4
      self.rumble = False
      self.ir_tracking = []
      self.raw_battery = 0.
      self.percent_battery = 0.
      self.zeroing_time = genpy.Time()
      self.errors = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_6d().pack(_x.angular_velocity_zeroed.x, _x.angular_velocity_zeroed.y, _x.angular_velocity_zeroed.z, _x.angular_velocity_raw.x, _x.angular_velocity_raw.y, _x.angular_velocity_raw.z))
      buff.write(_get_struct_9d().pack(*self.angular_velocity_covariance))
      _x = self
      buff.write(_get_struct_6d().pack(_x.linear_acceleration_zeroed.x, _x.linear_acceleration_zeroed.y, _x.linear_acceleration_zeroed.z, _x.linear_acceleration_raw.x, _x.linear_acceleration_raw.y, _x.linear_acceleration_raw.z))
      buff.write(_get_struct_9d().pack(*self.linear_acceleration_covariance))
      _x = self
      buff.write(_get_struct_6d().pack(_x.nunchuk_acceleration_zeroed.x, _x.nunchuk_acceleration_zeroed.y, _x.nunchuk_acceleration_zeroed.z, _x.nunchuk_acceleration_raw.x, _x.nunchuk_acceleration_raw.y, _x.nunchuk_acceleration_raw.z))
      buff.write(_get_struct_2f().pack(*self.nunchuk_joystick_zeroed))
      buff.write(_get_struct_2f().pack(*self.nunchuk_joystick_raw))
      buff.write(_get_struct_11B().pack(*self.buttons))
      buff.write(_get_struct_2B().pack(*self.nunchuk_buttons))
      buff.write(_get_struct_4B().pack(*self.LEDs))
      _x = self.rumble
      buff.write(_get_struct_B().pack(_x))
      length = len(self.ir_tracking)
      buff.write(_struct_I.pack(length))
      for val1 in self.ir_tracking:
        _x = val1
        buff.write(_get_struct_2dq().pack(_x.x, _x.y, _x.ir_size))
      _x = self
      buff.write(_get_struct_2f2IQ().pack(_x.raw_battery, _x.percent_battery, _x.zeroing_time.secs, _x.zeroing_time.nsecs, _x.errors))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.angular_velocity_zeroed is None:
        self.angular_velocity_zeroed = geometry_msgs.msg.Vector3()
      if self.angular_velocity_raw is None:
        self.angular_velocity_raw = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_zeroed is None:
        self.linear_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_raw is None:
        self.linear_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.nunchuk_acceleration_zeroed is None:
        self.nunchuk_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.nunchuk_acceleration_raw is None:
        self.nunchuk_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.ir_tracking is None:
        self.ir_tracking = None
      if self.zeroing_time is None:
        self.zeroing_time = genpy.Time()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 48
      (_x.angular_velocity_zeroed.x, _x.angular_velocity_zeroed.y, _x.angular_velocity_zeroed.z, _x.angular_velocity_raw.x, _x.angular_velocity_raw.y, _x.angular_velocity_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 72
      self.angular_velocity_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 48
      (_x.linear_acceleration_zeroed.x, _x.linear_acceleration_zeroed.y, _x.linear_acceleration_zeroed.z, _x.linear_acceleration_raw.x, _x.linear_acceleration_raw.y, _x.linear_acceleration_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 72
      self.linear_acceleration_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 48
      (_x.nunchuk_acceleration_zeroed.x, _x.nunchuk_acceleration_zeroed.y, _x.nunchuk_acceleration_zeroed.z, _x.nunchuk_acceleration_raw.x, _x.nunchuk_acceleration_raw.y, _x.nunchuk_acceleration_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 8
      self.nunchuk_joystick_zeroed = _get_struct_2f().unpack(str[start:end])
      start = end
      end += 8
      self.nunchuk_joystick_raw = _get_struct_2f().unpack(str[start:end])
      start = end
      end += 11
      self.buttons = _get_struct_11B().unpack(str[start:end])
      self.buttons = list(map(bool, self.buttons))
      start = end
      end += 2
      self.nunchuk_buttons = _get_struct_2B().unpack(str[start:end])
      self.nunchuk_buttons = list(map(bool, self.nunchuk_buttons))
      start = end
      end += 4
      self.LEDs = _get_struct_4B().unpack(str[start:end])
      self.LEDs = list(map(bool, self.LEDs))
      start = end
      end += 1
      (self.rumble,) = _get_struct_B().unpack(str[start:end])
      self.rumble = bool(self.rumble)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.ir_tracking = []
      for i in range(0, length):
        val1 = wiimote.msg.IrSourceInfo()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.ir_size,) = _get_struct_2dq().unpack(str[start:end])
        self.ir_tracking.append(val1)
      _x = self
      start = end
      end += 24
      (_x.raw_battery, _x.percent_battery, _x.zeroing_time.secs, _x.zeroing_time.nsecs, _x.errors,) = _get_struct_2f2IQ().unpack(str[start:end])
      self.zeroing_time.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_6d().pack(_x.angular_velocity_zeroed.x, _x.angular_velocity_zeroed.y, _x.angular_velocity_zeroed.z, _x.angular_velocity_raw.x, _x.angular_velocity_raw.y, _x.angular_velocity_raw.z))
      buff.write(self.angular_velocity_covariance.tostring())
      _x = self
      buff.write(_get_struct_6d().pack(_x.linear_acceleration_zeroed.x, _x.linear_acceleration_zeroed.y, _x.linear_acceleration_zeroed.z, _x.linear_acceleration_raw.x, _x.linear_acceleration_raw.y, _x.linear_acceleration_raw.z))
      buff.write(self.linear_acceleration_covariance.tostring())
      _x = self
      buff.write(_get_struct_6d().pack(_x.nunchuk_acceleration_zeroed.x, _x.nunchuk_acceleration_zeroed.y, _x.nunchuk_acceleration_zeroed.z, _x.nunchuk_acceleration_raw.x, _x.nunchuk_acceleration_raw.y, _x.nunchuk_acceleration_raw.z))
      buff.write(self.nunchuk_joystick_zeroed.tostring())
      buff.write(self.nunchuk_joystick_raw.tostring())
      buff.write(self.buttons.tostring())
      buff.write(self.nunchuk_buttons.tostring())
      buff.write(self.LEDs.tostring())
      _x = self.rumble
      buff.write(_get_struct_B().pack(_x))
      length = len(self.ir_tracking)
      buff.write(_struct_I.pack(length))
      for val1 in self.ir_tracking:
        _x = val1
        buff.write(_get_struct_2dq().pack(_x.x, _x.y, _x.ir_size))
      _x = self
      buff.write(_get_struct_2f2IQ().pack(_x.raw_battery, _x.percent_battery, _x.zeroing_time.secs, _x.zeroing_time.nsecs, _x.errors))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.angular_velocity_zeroed is None:
        self.angular_velocity_zeroed = geometry_msgs.msg.Vector3()
      if self.angular_velocity_raw is None:
        self.angular_velocity_raw = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_zeroed is None:
        self.linear_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.linear_acceleration_raw is None:
        self.linear_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.nunchuk_acceleration_zeroed is None:
        self.nunchuk_acceleration_zeroed = geometry_msgs.msg.Vector3()
      if self.nunchuk_acceleration_raw is None:
        self.nunchuk_acceleration_raw = geometry_msgs.msg.Vector3()
      if self.ir_tracking is None:
        self.ir_tracking = None
      if self.zeroing_time is None:
        self.zeroing_time = genpy.Time()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 48
      (_x.angular_velocity_zeroed.x, _x.angular_velocity_zeroed.y, _x.angular_velocity_zeroed.z, _x.angular_velocity_raw.x, _x.angular_velocity_raw.y, _x.angular_velocity_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 72
      self.angular_velocity_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 48
      (_x.linear_acceleration_zeroed.x, _x.linear_acceleration_zeroed.y, _x.linear_acceleration_zeroed.z, _x.linear_acceleration_raw.x, _x.linear_acceleration_raw.y, _x.linear_acceleration_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 72
      self.linear_acceleration_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 48
      (_x.nunchuk_acceleration_zeroed.x, _x.nunchuk_acceleration_zeroed.y, _x.nunchuk_acceleration_zeroed.z, _x.nunchuk_acceleration_raw.x, _x.nunchuk_acceleration_raw.y, _x.nunchuk_acceleration_raw.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 8
      self.nunchuk_joystick_zeroed = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=2)
      start = end
      end += 8
      self.nunchuk_joystick_raw = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=2)
      start = end
      end += 11
      self.buttons = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=11)
      self.buttons = list(map(bool, self.buttons))
      start = end
      end += 2
      self.nunchuk_buttons = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=2)
      self.nunchuk_buttons = list(map(bool, self.nunchuk_buttons))
      start = end
      end += 4
      self.LEDs = numpy.frombuffer(str[start:end], dtype=numpy.bool, count=4)
      self.LEDs = list(map(bool, self.LEDs))
      start = end
      end += 1
      (self.rumble,) = _get_struct_B().unpack(str[start:end])
      self.rumble = bool(self.rumble)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.ir_tracking = []
      for i in range(0, length):
        val1 = wiimote.msg.IrSourceInfo()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.ir_size,) = _get_struct_2dq().unpack(str[start:end])
        self.ir_tracking.append(val1)
      _x = self
      start = end
      end += 24
      (_x.raw_battery, _x.percent_battery, _x.zeroing_time.secs, _x.zeroing_time.nsecs, _x.errors,) = _get_struct_2f2IQ().unpack(str[start:end])
      self.zeroing_time.canon()
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_11B = None
def _get_struct_11B():
    global _struct_11B
    if _struct_11B is None:
        _struct_11B = struct.Struct("<11B")
    return _struct_11B
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2dq = None
def _get_struct_2dq():
    global _struct_2dq
    if _struct_2dq is None:
        _struct_2dq = struct.Struct("<2dq")
    return _struct_2dq
_struct_2f = None
def _get_struct_2f():
    global _struct_2f
    if _struct_2f is None:
        _struct_2f = struct.Struct("<2f")
    return _struct_2f
_struct_2f2IQ = None
def _get_struct_2f2IQ():
    global _struct_2f2IQ
    if _struct_2f2IQ is None:
        _struct_2f2IQ = struct.Struct("<2f2IQ")
    return _struct_2f2IQ
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_4B = None
def _get_struct_4B():
    global _struct_4B
    if _struct_4B is None:
        _struct_4B = struct.Struct("<4B")
    return _struct_4B
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_9d = None
def _get_struct_9d():
    global _struct_9d
    if _struct_9d is None:
        _struct_9d = struct.Struct("<9d")
    return _struct_9d
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
